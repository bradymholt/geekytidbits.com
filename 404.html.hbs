{{#> default }}
  <h1>Page Not Found</h1>
  <p>The page you were looking for could not be found. You might have mistyped the address or the page has
    moved. The <a href="/posts">Posts</a> page is a good place to start.</p>
  <style>
    /* 3D Canvas "404" Break-Apart Animation (self-contained) */
    .canvas404 {
      position: relative;
      height: clamp(280px, 45vw, 480px);
      margin: 1.5rem 0 2rem;
      border-radius: 14px;
      overflow: hidden;
      background:
        radial-gradient(1200px 500px at 15% 110%, hsl(215 70% 18% / 0.9), transparent),
        radial-gradient(900px 360px at 100% -5%, hsl(280 65% 25% / 0.7), transparent),
        linear-gradient(180deg, hsl(222 30% 12%), hsl(220 32% 8%));
      box-shadow:
        0 12px 32px hsl(220 40% 2% / 0.5),
        inset 0 -1px 0 hsl(0 0% 100% / 0.05);
    }
    .canvas404 canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: grab;
    }
    .canvas404 canvas:active { cursor: grabbing; }
    .canvas404::after {
      content: "";
      position: absolute;
      inset: -30% -15% 30% -15%;
      pointer-events: none;
      mix-blend-mode: overlay;
      background: radial-gradient(70% 40% at 50% 0%, hsl(0 0% 100% / 0.12), transparent 70%);
    }
    @media (prefers-reduced-motion: reduce) {
      .canvas404 { filter: brightness(0.9); }
    }
    .fallback404 {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font: 900 clamp(72px, 14vw, 180px)/0.85 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: hsl(220 50% 85%);
      text-align: center;
      text-shadow:
        0 0 20px hsl(210 100% 70% / 0.5),
        0 8px 16px hsl(0 0% 0% / 0.4);
    }
  </style>

  <div class="canvas404" aria-hidden="true">
    <canvas id="c404" role="img" aria-label="Animated 404 visualization"></canvas>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById('c404');
      if (!canvas) return;
      const ctx = canvas.getContext('2d', { alpha: false });
      const DPR = Math.min(2, window.devicePixelRatio || 1);

      let W = 0, H = 0, CX = 0, CY = 0;
      let prefersReduced = false;
      try {
        prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      } catch {}

      function resize() {
        const rect = canvas.getBoundingClientRect();
        W = Math.max(320, Math.floor(rect.width));
        H = Math.max(220, Math.floor(rect.height));
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        CX = W / 2;
        CY = H / 2;
        generateParticles();
      }

      // Particle system for text breakup/reform
      let particles = [];
      let targetPositions = [];

      function generateParticles() {
        // Create offscreen canvas to sample "404" text
        const off = document.createElement('canvas');
        const octx = off.getContext('2d');
        const pad = 32;
        off.width = Math.max(200, W - pad * 2);
        off.height = Math.max(120, H - pad * 2);

        const fontSize = Math.max(80, Math.floor(Math.min(off.width * 0.4, off.height * 0.9)));
        octx.clearRect(0, 0, off.width, off.height);
        octx.fillStyle = '#ffffff';
        octx.textAlign = 'center';
        octx.textBaseline = 'middle';
        octx.font = `900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
        octx.fillText('404', off.width / 2, off.height / 2);

        // Sample pixels to particles
        const step = Math.max(4, Math.floor(Math.min(off.width, off.height) / 80));
        const data = octx.getImageData(0, 0, off.width, off.height).data;

        particles = [];
        targetPositions = [];

        for (let y = 0; y < off.height; y += step) {
          for (let x = 0; x < off.width; x += step) {
            const idx = (y * off.width + x) * 4 + 3; // alpha
            if (data[idx] > 48) {
              // Target position (where particles should form "404")
              const targetX = (x - off.width / 2) * 0.8;
              const targetY = (y - off.height / 2) * 0.8;

              // Random starting position in 3D space
              const angle = Math.random() * Math.PI * 2;
              const radius = 200 + Math.random() * 300;
              const elevation = (Math.random() - 0.5) * 400;

              const particle = {
                // Current 3D position
                x: Math.cos(angle) * radius,
                y: elevation,
                z: Math.sin(angle) * radius,

                // Target 2D position for text formation
                targetX: targetX,
                targetY: targetY,
                targetZ: 0,

                // Initial scattered position
                startX: Math.cos(angle) * radius,
                startY: elevation,
                startZ: Math.sin(angle) * radius,

                // Animation properties
                phase: Math.random() * Math.PI * 2,
                speed: 0.8 + Math.random() * 0.4,
                size: 1.5 + Math.random() * 2.5
              };

              particles.push(particle);
            }
          }
        }

        // Limit particles for performance
        if (particles.length > 3000) {
          particles = particles.slice(0, 3000);
        }
      }

      // 3D rotation and camera
      let time = 0;
      let rotationY = 0;
      let rotationX = 0;
      const cameraZ = 800;

      // Cycle: 0=scattered -> 1=forming text -> 2=text formed -> 3=breaking apart
      function getCyclePhase(t) {
        const cycleTime = 8.0; // seconds per cycle
        const phase = (t % cycleTime) / cycleTime;

        if (phase < 0.25) {
          // Scattered to forming (0 -> 1)
          return { stage: 'forming', progress: phase * 4 };
        } else if (phase < 0.5) {
          // Text formed (1)
          return { stage: 'formed', progress: 1 };
        } else if (phase < 0.75) {
          // Breaking apart (1 -> 0)
          return { stage: 'breaking', progress: 1 - (phase - 0.5) * 4 };
        } else {
          // Scattered (0)
          return { stage: 'scattered', progress: 0 };
        }
      }

      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      function project3D(x, y, z) {
        // Apply rotations
        const cosY = Math.cos(rotationY);
        const sinY = Math.sin(rotationY);
        const cosX = Math.cos(rotationX);
        const sinX = Math.sin(rotationX);

        // Y rotation
        let rx = x * cosY - z * sinY;
        let rz = x * sinY + z * cosY;

        // X rotation
        let ry = y * cosX - rz * sinX;
        let rz2 = y * sinX + rz * cosX;

        // Perspective projection
        const distance = cameraZ - rz2;
        const scale = cameraZ / Math.max(1, distance);

        return {
          x: CX + rx * scale,
          y: CY + ry * scale,
          z: rz2,
          scale: scale
        };
      }

      function updateParticles() {
        const cycle = getCyclePhase(time);
        const easedProgress = easeInOutCubic(cycle.progress);

        particles.forEach(p => {
          // Interpolate between scattered and text positions
          p.x = p.startX + (p.targetX - p.startX) * easedProgress;
          p.y = p.startY + (p.targetY - p.startY) * easedProgress;
          p.z = p.startZ + (p.targetZ - p.startZ) * easedProgress;

          // Add subtle floating motion
          const float = Math.sin(time * p.speed + p.phase) * 8;
          p.y += float;

          // Add gentle orbital motion when scattered
          if (cycle.progress < 0.5) {
            const orbit = time * 0.3;
            const radius = 200 + Math.sin(time * 0.5 + p.phase) * 50;
            p.x += Math.cos(orbit + p.phase) * radius * (1 - easedProgress);
            p.z += Math.sin(orbit + p.phase) * radius * (1 - easedProgress);
          }
        });
      }

      function draw() {
        // Clear with gradient background
        const gradient = ctx.createRadialGradient(CX, CY, 0, CX, CY, Math.max(W, H) * 0.6);
        gradient.addColorStop(0, 'rgb(8, 12, 18)');
        gradient.addColorStop(1, 'rgb(4, 8, 14)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, W, H);

        // Sort particles by depth
        const projected = particles.map(p => ({
          particle: p,
          pos: project3D(p.x, p.y, p.z)
        })).sort((a, b) => a.pos.z - b.pos.z);

        // Draw particles
        projected.forEach(({ particle, pos }) => {
          const size = Math.max(0.8, particle.size * pos.scale * 0.8);
          const distance = Math.sqrt(pos.x * pos.x + pos.y * pos.y) / Math.max(W, H);

          // Color based on depth and distance from center
          const hue = 210 + particle.z * 0.1;
          const saturation = 80 + distance * 20;
          const lightness = 50 + pos.scale * 25 + Math.sin(time + particle.phase) * 8;

          ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${Math.min(95, lightness)}%)`;
          ctx.shadowColor = ctx.fillStyle;
          ctx.shadowBlur = size * 2;

          ctx.beginPath();
          ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = 0;
        });
      }

      function animate() {
        if (!prefersReduced) {
          time += 0.016;
          rotationY += 0.005;
          rotationX = Math.sin(time * 0.3) * 0.1;
        }

        updateParticles();
        draw();

        if (!prefersReduced) {
          requestAnimationFrame(animate);
        }
      }

      // Mouse/touch interaction for manual rotation
      let isDragging = false;
      let lastX = 0, lastY = 0;

      function handlePointerStart(e) {
        isDragging = true;
        lastX = e.clientX || e.touches[0].clientX;
        lastY = e.clientY || e.touches[0].clientY;
      }

      function handlePointerMove(e) {
        if (!isDragging) return;
        e.preventDefault();

        const x = e.clientX || e.touches[0].clientX;
        const y = e.clientY || e.touches[0].clientY;

        rotationY += (x - lastX) * 0.01;
        rotationX += (y - lastY) * 0.01;
        rotationX = Math.max(-0.5, Math.min(0.5, rotationX));

        lastX = x;
        lastY = y;
      }

      function handlePointerEnd() {
        isDragging = false;
      }

      canvas.addEventListener('mousedown', handlePointerStart);
      canvas.addEventListener('mousemove', handlePointerMove);
      canvas.addEventListener('mouseup', handlePointerEnd);
      canvas.addEventListener('touchstart', handlePointerStart);
      canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
      canvas.addEventListener('touchend', handlePointerEnd);

      window.addEventListener('resize', resize);

      resize();
      animate();
    })();
  </script>
  <noscript>
    <div class="canvas404" aria-hidden="true">
      <div class="fallback404">404</div>
    </div>
  </noscript>
{{/default}}
